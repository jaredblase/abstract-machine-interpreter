import { LRParser } from '@lezer/lr';
import { LRLanguage, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { completeFromList } from '@codemirror/autocomplete';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
	version: 14,
	states: "%vOYQPOOObQPO'#C_OjQQO'#CcQOQPOOO]QPOOOrQPO,58yOzQQO'#ClO!PQPO'#CeO!UQQO,58}OOQO'#Cm'#CmOOQO-E6j-E6jOOQO,59W,59WO!^QPO,59POOQO-E6k-E6kO!iQPO1G.kO!nQPO1G.kO!sQSO'#CgOOQO'#Ct'#CtO!xQQO'#CsOOQO7+$V7+$VO#TQQO7+$VO#YQPO,59RO!iQPO'#CnO#bQQO,59_O#mQPO<<GqO#rQQO1G.mO#wQSO1G.oOOQO,59Y,59YOOQO-E6l-E6lO!iQPOAN=]O#|QPO7+$XO$RQPO7+$ZOOQOG22wG22wOOQO<<Gs<<GsO$WQQO<<GuO$]QPOAN=aOOQOG22{G22{",
	stateData: "$g~OeOSPOS~OSPOWQO~OTUOWRX~OUVOcVX~OTUOWRa~OUZO~Of[O~OUVOcVa~OY^O^_O__O~Oi`O~OidO~O[eO~OjfOUgXcgX~OUhO~OjiOljO~OjfOUgacga~OkmO~OUnO~O[oO~OkqO~OjrO~OUsO~OktO~OPe[e~",
	goto: "!kiPPPjPPPmPqPuPuPPz!Q!WPPPP!^!dRSOTROSTXQWVa^fmQTPRYTQWQR]WQgbRlgQc^RpmSb^mRkf",
	nodeNames: "âš  LineComment Program DataSection .DATA StorageType Identifier LogicSection .LOGIC State FSACommand Transition Symbol TMTransition PDACommand TMCommand",
	maxTerm: 28,
	skippedNodes: [0, 1],
	repeatNodeCount: 3,
	tokenData: "Bd~R!ZOX$tX^$y^p$tpq$yqx$txy&eyz&lz|$t|}&s}!O&z!O!P'v!P!Q)X!Q!S&z!S!T)`!T![&z![!]$t!]!^-R!^!c$t!c!f&z!f!g-r!g!n&z!n!o/|!o!r&z!r!s1p!s!t4f!t!u6Y!u!v9m!v!w>p!w!x?Z!x!y&z!y!z?w!z!}&z!}#P$t#P#QBV#Q#R$t#R#S&z#S#T$t#T#o&z#o#y$t#y#z$y#z$f$t$f$g$y$g#BY$t#BY#BZ$y#BZ$IS$t$IS$I_$y$I_$I|$t$I|$JO$y$JO$JT$t$JT$JU$y$JU$KV$t$KV$KW$y$KW&FU$t&FU&FV$y&FV;'S$t;'S;=`B^<%lO$tS$yO[S~%QYe~[SX^%ppq%p#y#z%p$f$g%p#BY#BZ%p$IS$I_%p$I|$JO%p$JT$JU%p$KV$KW%p&FU&FV%p~%uYe~X^%ppq%p#y#z%p$f$g%p#BY#BZ%p$IS$I_%p$I|$JO%p$JT$JU%p$KV$KW%p&FU&FV%pT&lOiP[ST&sOkP[SV&zOjR[SU'RTUQ[S}!O'b!Q!['b!c!}'b#R#S'b#T#o'bQ'gTUQ}!O'b!Q!['b!c!}'b#R#S'b#T#o'bT'{Q[S!f!g(R!n!o(jP(UP!c!d(XP([P!v!w(_P(bP!c!d(eP(jOSPP(mP!q!r(pP(sP!i!j(vP(yP!k!l(|P)PP!e!f)SP)XOWPT)`OlP[SV)gVUQ[S}!O'b!Q!['b!c!f'b!f!g)|!g!}'b#R#S'b#T#o'bR*RTUQ}!O'b!Q!['b!c!}'b#R#S*b#T#o'bR*gVUQ}!O'b!Q!['b!c!v'b!v!w*|!w!}'b#R#S'b#T#o'bR+RUUQ}!O'b!Q!['b!c!d+e!d!}'b#R#S'b#T#o'bR+jVUQ}!O'b!Q!['b!c!r'b!r!s,P!s!}'b#R#S'b#T#o'bR,UVUQ}!O'b!Q!['b!c!g'b!g!h,k!h!}'b#R#S'b#T#o'bR,rTUQTP}!O'b!Q!['b!c!}'b#R#S'b#T#o'b~-WP[S!]!^-Z~-`SP~OY-ZZ;'S-Z;'S;=`-l<%lO-Z~-oP;=`<%l-ZV-yVUQ[S}!O'b!Q!['b!c!q'b!q!r.`!r!}'b#R#S'b#T#o'bR.eVUQ}!O'b!Q!['b!c!y'b!y!z.z!z!}'b#R#S'b#T#o'bR/PVUQ}!O'b!Q!['b!c!p'b!p!q/f!q!}'b#R#S'b#T#o'bR/mTUQ_P}!O'b!Q!['b!c!}'b#R#S'b#T#o'bV0TVUQ[S}!O'b!Q!['b!c!g'b!g!h0j!h!}'b#R#S'b#T#o'bR0oVUQ}!O'b!Q!['b!c!h'b!h!i1U!i!}'b#R#S'b#T#o'bR1ZVUQ}!O'b!Q!['b!c!v'b!v!w/f!w!}'b#R#S'b#T#o'bV1wVUQ[S}!O'b!Q!['b!c!t'b!t!u2^!u!}'b#R#S'b#T#o'bR2cVUQ}!O'b!Q!['b!c!k'b!k!l2x!l!}'b#R#S'b#T#o'bR2}VUQ}!O'b!Q!['b!c!p'b!p!q3d!q!}'b#R#S'b#T#o'bR3iVUQ}!O'b!Q!['b!c!v'b!v!w4O!w!}'b#R#S'b#T#o'bR4VTYPUQ}!O'b!Q!['b!c!}'b#R#S'b#T#o'bV4mVUQ[S}!O'b!Q!['b!c!w'b!w!x5S!x!}'b#R#S'b#T#o'bR5XVUQ}!O'b!Q!['b!c!g'b!g!h5n!h!}'b#R#S'b#T#o'bR5sVUQ}!O'b!Q!['b!c!w'b!w!x,P!x!}'b#R#S'b#T#o'bV6aXUQ[S}!O'b!Q!['b!c!g'b!g!h6|!h!k'b!k!l8g!l!}'b#R#S'b#T#o'bR7RUUQ}!O'b!Q!['b!c!d7e!d!}'b#R#S'b#T#o'bR7jVUQ}!O'b!Q!['b!c!f'b!f!g8P!g!}'b#R#S'b#T#o'bR8WTUQ^P}!O'b!Q!['b!c!}'b#R#S'b#T#o'bR8lVUQ}!O'b!Q!['b!c!i'b!i!j9R!j!}'b#R#S'b#T#o'bR9WVUQ}!O'b!Q!['b!c!j'b!j!k1U!k!}'b#R#S'b#T#o'bV9tXUQ[S}!O'b!Q!['b!c!e'b!e!f:a!f!v'b!v!w=R!w!}'b#R#S'b#T#o'bR:fUUQ}!O'b!Q!['b!c!d:x!d!}'b#R#S'b#T#o'bR:}VUQ}!O'b!Q!['b!c!p'b!p!q;d!q!}'b#R#S'b#T#o'bR;kUYPUQpq;}}!O'b!Q!['b!c!}'b#R#S'b#T#o'bP<QQ!n!o<W!t!u<oP<ZP!g!h<^P<aP!h!i<dP<gP!v!w<jP<oOYPP<rP!k!l<uP<xP!i!j<{P=OP!j!k<dR=WUUQ}!O'b!Q!['b!c!d=j!d!}'b#R#S'b#T#o'bR=oVUQ}!O'b!Q!['b!c!e'b!e!f>U!f!}'b#R#S'b#T#o'bR>ZVUQ}!O'b!Q!['b!c!m'b!m!n,k!n!}'b#R#S'b#T#o'bV>wUUQ[S}!O'b!Q!['b!c!d+e!d!}'b#R#S'b#T#o'bV?bVUQ[S}!O'b!Q!['b!c!r'b!r!s/f!s!}'b#R#S'b#T#o'bV@OVUQ[S}!O'b!Q!['b!c!t'b!t!u@e!u!}'b#R#S'b#T#o'bR@jVUQ}!O'b!Q!['b!c!k'b!k!lAP!l!}'b#R#S'b#T#o'bRAUVUQ}!O'b!Q!['b!c!v'b!v!wAk!w!}'b#R#S'b#T#o'bRApVUQ}!O'b!Q!['b!c!g'b!g!h8P!h!}'b#R#S'b#T#o'bTB^OfP[SSBaP;=`<%l$t",
	tokenizers: [0, 1, 2],
	topRules: { "Program": [0, 2] },
	tokenPrec: 156
});

const AbsMacLanguage = LRLanguage.define({
	parser: parser.configure({
		props: [
			foldNodeProp.add({
				DataSection: foldInside,
				LogicSection: foldInside
			}),
			styleTags({
				Symbol: tags.number,
				Identifier: tags.variableName,
				LineComment: tags.lineComment,
				StorageType: tags.bool,
				FSACommand: tags.className,
				PDACommand: tags.className,
				TMCommand: tags.className,
				".DATA": tags.string,
				".LOGIC": tags.string,
			})
		]
	}),
	languageData: {
		commentTokens: { line: ";;" }
	}
});
const AbsMacCompletion = AbsMacLanguage.data.of({
	autocomplete: completeFromList([
		{ label: '.DATA', type: 'text' },
		{ label: '.LOGIC', type: 'text' },
		{ label: 'STACK', type: 'type' },
		{ label: 'QUEUE', type: 'type' },
		{ label: 'TAPE', type: 'type' },
		{ label: '2D_TAPE', type: 'type' },
		{ label: 'SCAN', type: 'keyword' },
		{ label: 'PRINT', type: 'keyword' },
		{ label: 'SCAN RIGHT', type: 'keyword' },
		{ label: 'SCAN LEFT', type: 'keyword' },
		{ label: 'READ', type: 'keyword' },
		{ label: 'WRITE', type: 'keyword' },
		{ label: 'RIGHT', type: 'keyword' },
		{ label: 'LEFT', type: 'keyword' },
		{ label: 'UP', type: 'keyword' },
		{ label: 'DOWN', type: 'keyword' },
		{ label: 'accept', type: 'keyword' },
		{ label: 'reject', type: 'keyword' },
	])
});
function AbsMac() {
	return new LanguageSupport(AbsMacLanguage, [AbsMacCompletion]);
}

export { AbsMac, AbsMacCompletion, AbsMacLanguage };
