import { LRParser } from '@lezer/lr';
import { LRLanguage, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { completeFromList } from '@codemirror/autocomplete';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
	version: 14,
	states: "'UOYQPOOObQPO'#C_OjQQO'#CcQOQPOOO]QPOOOrQPO,58yOzQQO'#ClO!PQPO'#CeO!UQQO,58}OOQO'#Cm'#CmOOQO-E6j-E6jOOQO,59W,59WO!^QPO,59POOQO-E6k-E6kO!iQPO1G.kO!nQPO1G.kO!sQPO1G.kO!xQSO'#CgOOQO7+$V7+$VO!}QQO'#CtO#YQQO7+$VO#_QQO7+$VO#dQPO,59RO#iQQO,59`O!iQPO'#CnO#tQPO<<GqO#yQPO<<GqO$OQQO1G.mOOQO-E6l-E6lOOQO,59Y,59YO!iQPOAN=]O$TQPOAN=]O$YQPO7+$XOOQOG22wG22wO$_QSO'#CkO$dQQO'#CxOOQO<<Gs<<GsO$oQPO,59VO$tQQO,59dO$TQPO'#CoO%PQSO1G.qOOQO-E6m-E6mOOQO,59Z,59ZO%UQPO7+$]O%ZQQO<<GwO%`QPOAN=cOOQOG22}G22}",
	stateData: "%e~OfOSPOS~OSPOWQO~OTUOWRX~OUVOdVX~OTUOWRa~OUZO~Og[O~OUVOdVa~OY^O]_O^`O~OiaO~OidO~OieO~O[fO~OjhOUhXdhX~OUiO~OUjO~OjkO~OjhOUhadha~OknO~OkoO~OUpO~OirO~OktO~O[uO~OjwOUlXdlX~OmxO~OjwOUladla~O[{O~Oj|O~OU}O~Ok!OO~O",
	goto: "!ymPPPnPPPqPuPyPPP!Q!W!^!d!jPPPP!pPPP!vRSOTROSTXQWSc^nRmhQsoRzwQTPRYTQWQR]WQgcRlgQvsRyvQb^RqnRqo",
	nodeNames: "âš  LineComment Program DataSection .DATA StorageType Identifier LogicSection .LOGIC Transition FSACommand State Symbol PDACommand TMCommand TapeState",
	maxTerm: 29,
	skippedNodes: [0, 1],
	repeatNodeCount: 4,
	tokenData: "=c~RsX^#`pq#`st$Txy$lyz$q|}$v}!O${!O!P%w!P!Q'W!Q![${!c!f${!f!g']!g!n${!n!o)g!o!r${!r!s+Z!s!t.P!t!u0u!u!v4Y!v!w9]!w!x:b!x!y${!y!z;O!z!}${#P#Q=^#R#S${#T#o${#y#z#`$f$g#`#BY#BZ#`$IS$I_#`$I|$JO#`$JT$JU#`$KV$KW#`&FU&FV#`~#eYf~X^#`pq#`#y#z#`$f$g#`#BY#BZ#`$IS$I_#`$I|$JO#`$JT$JU#`$KV$KW#`&FU&FV#`~$YSP~OY$TZ;'S$T;'S;=`$f<%lO$T~$iP;=`<%l$T~$qOi~~$vOk~~${Oj~U%STUQ[S}!O%c!Q![%c!c!}%c#R#S%c#T#o%cQ%hTUQ}!O%c!Q![%c!c!}%c#R#S%c#T#o%c~%zQ!f!g&Q!n!o&i~&TP!c!d&W~&ZP!v!w&^~&aP!c!d&d~&iOS~~&lP!q!r&o~&rP!i!j&u~&xP!k!l&{~'OP!e!f'R~'WOW~~']Om~V'dVUQ[S}!O%c!Q![%c!c!q%c!q!r'y!r!}%c#R#S%c#T#o%cR(OVUQ}!O%c!Q![%c!c!y%c!y!z(e!z!}%c#R#S%c#T#o%cR(jVUQ}!O%c!Q![%c!c!p%c!p!q)P!q!}%c#R#S%c#T#o%cR)WTUQ^P}!O%c!Q![%c!c!}%c#R#S%c#T#o%cV)nVUQ[S}!O%c!Q![%c!c!g%c!g!h*T!h!}%c#R#S%c#T#o%cR*YVUQ}!O%c!Q![%c!c!h%c!h!i*o!i!}%c#R#S%c#T#o%cR*tVUQ}!O%c!Q![%c!c!v%c!v!w)P!w!}%c#R#S%c#T#o%cV+bVUQ[S}!O%c!Q![%c!c!t%c!t!u+w!u!}%c#R#S%c#T#o%cR+|VUQ}!O%c!Q![%c!c!k%c!k!l,c!l!}%c#R#S%c#T#o%cR,hVUQ}!O%c!Q![%c!c!p%c!p!q,}!q!}%c#R#S%c#T#o%cR-SVUQ}!O%c!Q![%c!c!v%c!v!w-i!w!}%c#R#S%c#T#o%cR-pTYPUQ}!O%c!Q![%c!c!}%c#R#S%c#T#o%cV.WVUQ[S}!O%c!Q![%c!c!w%c!w!x.m!x!}%c#R#S%c#T#o%cR.rVUQ}!O%c!Q![%c!c!g%c!g!h/X!h!}%c#R#S%c#T#o%cR/^VUQ}!O%c!Q![%c!c!w%c!w!x/s!x!}%c#R#S%c#T#o%cR/xVUQ}!O%c!Q![%c!c!g%c!g!h0_!h!}%c#R#S%c#T#o%cR0fTUQTP}!O%c!Q![%c!c!}%c#R#S%c#T#o%cV0|XUQ[S}!O%c!Q![%c!c!g%c!g!h1i!h!k%c!k!l3S!l!}%c#R#S%c#T#o%cR1nUUQ}!O%c!Q![%c!c!d2Q!d!}%c#R#S%c#T#o%cR2VVUQ}!O%c!Q![%c!c!f%c!f!g2l!g!}%c#R#S%c#T#o%cR2sTUQ]P}!O%c!Q![%c!c!}%c#R#S%c#T#o%cR3XVUQ}!O%c!Q![%c!c!i%c!i!j3n!j!}%c#R#S%c#T#o%cR3sVUQ}!O%c!Q![%c!c!j%c!j!k*o!k!}%c#R#S%c#T#o%cV4aXUQ[S}!O%c!Q![%c!c!e%c!e!f4|!f!v%c!v!w7n!w!}%c#R#S%c#T#o%cR5RUUQ}!O%c!Q![%c!c!d5e!d!}%c#R#S%c#T#o%cR5jVUQ}!O%c!Q![%c!c!p%c!p!q6P!q!}%c#R#S%c#T#o%cR6WUYPUQpq6j}!O%c!Q![%c!c!}%c#R#S%c#T#o%cP6mQ!n!o6s!t!u7[P6vP!g!h6yP6|P!h!i7PP7SP!v!w7VP7[OYPP7_P!k!l7bP7eP!i!j7hP7kP!j!k7PR7sUUQ}!O%c!Q![%c!c!d8V!d!}%c#R#S%c#T#o%cR8[VUQ}!O%c!Q![%c!c!e%c!e!f8q!f!}%c#R#S%c#T#o%cR8vVUQ}!O%c!Q![%c!c!m%c!m!n0_!n!}%c#R#S%c#T#o%cV9dUUQ[S}!O%c!Q![%c!c!d9v!d!}%c#R#S%c#T#o%cR9{VUQ}!O%c!Q![%c!c!r%c!r!s/s!s!}%c#R#S%c#T#o%cV:iVUQ[S}!O%c!Q![%c!c!r%c!r!s)P!s!}%c#R#S%c#T#o%cV;VVUQ[S}!O%c!Q![%c!c!t%c!t!u;l!u!}%c#R#S%c#T#o%cR;qVUQ}!O%c!Q![%c!c!k%c!k!l<W!l!}%c#R#S%c#T#o%cR<]VUQ}!O%c!Q![%c!c!v%c!v!w<r!w!}%c#R#S%c#T#o%cR<wVUQ}!O%c!Q![%c!c!g%c!g!h2l!h!}%c#R#S%c#T#o%c~=cOg~",
	tokenizers: [0, 1, 2],
	topRules: { "Program": [0, 2] },
	tokenPrec: 0
});

const AbsMacLanguage = LRLanguage.define({
	parser: parser.configure({
		props: [
			foldNodeProp.add({
				DataSection: foldInside,
				LogicSection: foldInside,
			}),
			styleTags({
				Symbol: tags.number,
				Identifier: tags.variableName,
				LineComment: tags.lineComment,
				StorageType: tags.bool,
				FSACommand: tags.className,
				PDACommand: tags.className,
				TMCommand: tags.className,
				".DATA": tags.string,
				".LOGIC": tags.string,
			})
		]
	}),
	languageData: {
		commentTokens: { line: "#" }
	}
});
const AbsMacCompletion = AbsMacLanguage.data.of({
	autocomplete: completeFromList([
		{ label: '.DATA', type: 'text' },
		{ label: '.LOGIC', type: 'text' },
		{ label: 'STACK', type: 'type' },
		{ label: 'QUEUE', type: 'type' },
		{ label: 'TAPE', type: 'type' },
		{ label: 'SCAN', type: 'keyword' },
		{ label: 'PRINT', type: 'keyword' },
		{ label: 'SCAN RIGHT', type: 'keyword' },
		{ label: 'SCAN LEFT', type: 'keyword' },
		{ label: 'READ', type: 'keyword' },
		{ label: 'WRITE', type: 'keyword' },
		{ label: 'RIGHT', type: 'keyword' },
		{ label: 'LEFT', type: 'keyword' },
		{ label: 'UP', type: 'keyword' },
		{ label: 'DOWN', type: 'keyword' },
	])
});
function AbsMac() {
	return new LanguageSupport(AbsMacLanguage, [AbsMacCompletion]);
}

export { AbsMac, AbsMacCompletion, AbsMacLanguage };
