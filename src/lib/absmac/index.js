import { LRParser } from '@lezer/lr';
import { LRLanguage, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { completeFromList } from '@codemirror/autocomplete';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
  version: 14,
  states: "'UOYQPOOObQPO'#C_OjQQO'#CcQOQPOOO]QPOOOrQPO,58yOzQQO'#CiO!PQPO'#CpOOQO'#Cj'#CjO!UQQO,58}OOQO-E6g-E6gOOQO,59T,59TO!^QPO,59[OOQO-E6h-E6hO!iQPO1G.vO!nQPO1G.vO!sQPO1G.vO!xQSO'#CsO!}QQO'#CrOOQO7+$b7+$bO#YQQO7+$bO#_QQO7+$bO#dQPO,59_O!iQPO'#CkO#iQQO,59^O#tQPO<<G|O#yQPO<<G|O$OQQO1G.yOOQO,59V,59VOOQO-E6i-E6iO!iQPOAN=hO$TQPOAN=hO$YQPO7+$eOOQOG23SG23SO$_QSO'#CxO$dQQO'#CwOOQO<<HP<<HPO$oQPO,59dO$TQPO'#ClO$tQQO,59cO%PQSO1G/OOOQO,59W,59WOOQO-E6j-E6jO%UQPO7+$jO%ZQQO<<HUO%`QPOAN=pOOQOG23[G23[",
  stateData: "%e~OcOSPOS~OSPOWQO~OTUOWRX~OUVOaVX~OTUOWRa~OUZO~Oe[O~OUVOaVa~OX^OZ_O[`O~OhaO~OhdO~OheO~OYfO~OigOUfXafX~OUiO~OUjO~OikO~OigOUfaafa~OjnO~OjoO~OUpO~OhrO~OjtO~OYuO~OivOUkXakX~OmxO~OivOUkaaka~OY{O~Oi|O~OU}O~Oj!OO~O",
  goto: "!ymPPPnPPPqPPPPPu{!R!XPPP!_P!c!iPPP!p!sRSOTROSQTPRYTQXQR]XQhbRmhQwsRzwTWQXQc^RqnSb^nRlgRqoQsoRyv",
  nodeNames: "âš  LineComment Program DataSection .DATA StorageType Identifier LogicSection .LOGIC Command Symbol DataCommand TapeCommand",
  maxTerm: 29,
  skippedNodes: [0,1],
  repeatNodeCount: 4,
  tokenData: "=c~RsX^#`pq#`st$Txy$lyz$q|}$v}!O${!O!P%w!P!Q'W!Q![${!c!f${!f!g']!g!n${!n!o)g!o!r${!r!s+Z!s!t.P!t!u0u!u!v4Y!v!w9]!w!x:b!x!y${!y!z;O!z!}${#P#Q=^#R#S${#T#o${#y#z#`$f$g#`#BY#BZ#`$IS$I_#`$I|$JO#`$JT$JU#`$KV$KW#`&FU&FV#`~#eYc~X^#`pq#`#y#z#`$f$g#`#BY#BZ#`$IS$I_#`$I|$JO#`$JT$JU#`$KV$KW#`&FU&FV#`~$YSP~OY$TZ;'S$T;'S;=`$f<%lO$T~$iP;=`<%l$T~$qOh~~$vOj~~${Oi~U%STUQYS}!O%c!Q![%c!c!}%c#R#S%c#T#o%cQ%hTUQ}!O%c!Q![%c!c!}%c#R#S%c#T#o%c~%zQ!f!g&Q!n!o&i~&TP!c!d&W~&ZP!v!w&^~&aP!c!d&d~&iOS~~&lP!q!r&o~&rP!i!j&u~&xP!k!l&{~'OP!e!f'R~'WOW~~']Om~V'dVUQYS}!O%c!Q![%c!c!q%c!q!r'y!r!}%c#R#S%c#T#o%cR(OVUQ}!O%c!Q![%c!c!y%c!y!z(e!z!}%c#R#S%c#T#o%cR(jVUQ}!O%c!Q![%c!c!p%c!p!q)P!q!}%c#R#S%c#T#o%cR)WTUQ[P}!O%c!Q![%c!c!}%c#R#S%c#T#o%cV)nVUQYS}!O%c!Q![%c!c!g%c!g!h*T!h!}%c#R#S%c#T#o%cR*YVUQ}!O%c!Q![%c!c!h%c!h!i*o!i!}%c#R#S%c#T#o%cR*tVUQ}!O%c!Q![%c!c!v%c!v!w)P!w!}%c#R#S%c#T#o%cV+bVUQYS}!O%c!Q![%c!c!t%c!t!u+w!u!}%c#R#S%c#T#o%cR+|VUQ}!O%c!Q![%c!c!k%c!k!l,c!l!}%c#R#S%c#T#o%cR,hVUQ}!O%c!Q![%c!c!p%c!p!q,}!q!}%c#R#S%c#T#o%cR-SVUQ}!O%c!Q![%c!c!v%c!v!w-i!w!}%c#R#S%c#T#o%cR-pTXPUQ}!O%c!Q![%c!c!}%c#R#S%c#T#o%cV.WVUQYS}!O%c!Q![%c!c!w%c!w!x.m!x!}%c#R#S%c#T#o%cR.rVUQ}!O%c!Q![%c!c!g%c!g!h/X!h!}%c#R#S%c#T#o%cR/^VUQ}!O%c!Q![%c!c!w%c!w!x/s!x!}%c#R#S%c#T#o%cR/xVUQ}!O%c!Q![%c!c!g%c!g!h0_!h!}%c#R#S%c#T#o%cR0fTUQTP}!O%c!Q![%c!c!}%c#R#S%c#T#o%cV0|XUQYS}!O%c!Q![%c!c!g%c!g!h1i!h!k%c!k!l3S!l!}%c#R#S%c#T#o%cR1nUUQ}!O%c!Q![%c!c!d2Q!d!}%c#R#S%c#T#o%cR2VVUQ}!O%c!Q![%c!c!f%c!f!g2l!g!}%c#R#S%c#T#o%cR2sTZPUQ}!O%c!Q![%c!c!}%c#R#S%c#T#o%cR3XVUQ}!O%c!Q![%c!c!i%c!i!j3n!j!}%c#R#S%c#T#o%cR3sVUQ}!O%c!Q![%c!c!j%c!j!k*o!k!}%c#R#S%c#T#o%cV4aXUQYS}!O%c!Q![%c!c!e%c!e!f4|!f!v%c!v!w7n!w!}%c#R#S%c#T#o%cR5RUUQ}!O%c!Q![%c!c!d5e!d!}%c#R#S%c#T#o%cR5jVUQ}!O%c!Q![%c!c!p%c!p!q6P!q!}%c#R#S%c#T#o%cR6WUXPUQpq6j}!O%c!Q![%c!c!}%c#R#S%c#T#o%cP6mQ!n!o6s!t!u7[P6vP!g!h6yP6|P!h!i7PP7SP!v!w7VP7[OXPP7_P!k!l7bP7eP!i!j7hP7kP!j!k7PR7sUUQ}!O%c!Q![%c!c!d8V!d!}%c#R#S%c#T#o%cR8[VUQ}!O%c!Q![%c!c!e%c!e!f8q!f!}%c#R#S%c#T#o%cR8vVUQ}!O%c!Q![%c!c!m%c!m!n0_!n!}%c#R#S%c#T#o%cV9dUUQYS}!O%c!Q![%c!c!d9v!d!}%c#R#S%c#T#o%cR9{VUQ}!O%c!Q![%c!c!r%c!r!s/s!s!}%c#R#S%c#T#o%cV:iVUQYS}!O%c!Q![%c!c!r%c!r!s)P!s!}%c#R#S%c#T#o%cV;VVUQYS}!O%c!Q![%c!c!t%c!t!u;l!u!}%c#R#S%c#T#o%cR;qVUQ}!O%c!Q![%c!c!k%c!k!l<W!l!}%c#R#S%c#T#o%cR<]VUQ}!O%c!Q![%c!c!v%c!v!w<r!w!}%c#R#S%c#T#o%cR<wVUQ}!O%c!Q![%c!c!g%c!g!h2l!h!}%c#R#S%c#T#o%c~=cOe~",
  tokenizers: [0, 1, 2],
  topRules: {"Program":[0,2]},
  tokenPrec: 0
});

const AbsMacLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            foldNodeProp.add({
                DataSection: foldInside,
                LogicSection: foldInside,
            }),
            styleTags({
                Symbol: tags.number,
                Identifier: tags.variableName,
                LineComment: tags.lineComment,
                StorageType: tags.bool,
                Command: tags.className,
                DataCommand: tags.className,
                TapeCommand: tags.className,
                ".DATA": tags.string,
                ".LOGIC": tags.string,
                "( )": tags.paren,
            })
        ]
    }),
    languageData: {
        commentTokens: { line: "#" }
    }
});
const AbsMacCompletion = AbsMacLanguage.data.of({
    autocomplete: completeFromList([
        { label: '.DATA', type: 'text' },
        { label: '.LOGIC', type: 'text' },
        { label: 'STACK', type: 'type' },
        { label: 'QUEUE', type: 'type' },
        { label: 'TAPE', type: 'type' },
        { label: 'SCAN', type: 'keyword' },
        { label: 'PRINT', type: 'keyword' },
        { label: 'SCAN RIGHT', type: 'keyword' },
        { label: 'SCAN LEFT', type: 'keyword' },
        { label: 'READ', type: 'keyword' },
        { label: 'WRITE', type: 'keyword' },
        { label: 'RIGHT', type: 'keyword' },
        { label: 'LEFT', type: 'keyword' },
        { label: 'UP', type: 'keyword' },
        { label: 'DOWN', type: 'keyword' },
    ])
});
function AbsMac() {
    return new LanguageSupport(AbsMacLanguage, [AbsMacCompletion]);
}

export { AbsMac, AbsMacCompletion, AbsMacLanguage };
