import { LRParser } from '@lezer/lr';
import { LRLanguage, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { completeFromList } from '@codemirror/autocomplete';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
	version: 14,
	states: "%vOYQPOOObQPO'#C_OjQQO'#CcQOQPOOO]QPOOOrQPO,58yOzQQO'#ClO!PQPO'#CeO!UQQO,58}OOQO'#Cm'#CmOOQO-E6j-E6jOOQO,59W,59WO!^QPO,59POOQO-E6k-E6kO!iQPO1G.kO!nQPO1G.kO!sQSO'#CgOOQO'#Ct'#CtO!xQQO'#CsOOQO7+$V7+$VO#TQQO7+$VO#YQPO,59RO!iQPO'#CnO#bQQO,59_O#mQPO<<GqO#rQQO1G.mO#wQSO1G.oOOQO,59Y,59YOOQO-E6l-E6lO!iQPOAN=]O#|QPO7+$XO$RQPO7+$ZOOQOG22wG22wOOQO<<Gs<<GsO$WQQO<<GuO$]QPOAN=aOOQOG22{G22{",
	stateData: "$g~OeOSPOS~OSPOWQO~OTUOWRX~OUVOcVX~OTUOWRa~OUZO~Of[O~OUVOcVa~OY^O^_O__O~Oi`O~OidO~O[eO~OjfOUgXcgX~OUhO~OjiOljO~OjfOUgacga~OkmO~OUnO~O[oO~OkqO~OjrO~OUsO~OktO~OPe[e~",
	goto: "!kiPPPjPPPmPqPuPuPPz!Q!WPPPP!^!dRSOTROSTXQWVa^fmQTPRYTQWQR]WQgbRlgQc^RpmSb^mRkf",
	nodeNames: "âš  LineComment Program DataSection .DATA StorageType Identifier LogicSection .LOGIC State FSACommand Transition Symbol TMTransition PDACommand TMCommand",
	maxTerm: 28,
	skippedNodes: [0, 1],
	repeatNodeCount: 3,
	tokenData: "@X~R!XOX$nX^$s^p$npq$sqx$nxy&_yz&fz|$n|}&m}!O&t!O!P'p!P!Q)R!Q![&t![!]$n!]!^)Y!^!c$n!c!f&t!f!g)y!g!n&t!n!o,T!o!r&t!r!s-w!s!t0m!t!u3c!u!v6v!v!w;y!w!x=O!x!y&t!y!z=l!z!}&t!}#P$n#P#Q?z#Q#R$n#R#S&t#S#T$n#T#o&t#o#y$n#y#z$s#z$f$n$f$g$s$g#BY$n#BY#BZ$s#BZ$IS$n$IS$I_$s$I_$I|$n$I|$JO$s$JO$JT$n$JT$JU$s$JU$KV$n$KV$KW$s$KW&FU$n&FU&FV$s&FV;'S$n;'S;=`@R<%lO$nS$sO[S~$zYe~[SX^%jpq%j#y#z%j$f$g%j#BY#BZ%j$IS$I_%j$I|$JO%j$JT$JU%j$KV$KW%j&FU&FV%j~%oYe~X^%jpq%j#y#z%j$f$g%j#BY#BZ%j$IS$I_%j$I|$JO%j$JT$JU%j$KV$KW%j&FU&FV%jT&fOiP[ST&mOkP[SV&tOjR[SU&{TUQ[S}!O'[!Q!['[!c!}'[#R#S'[#T#o'[Q'aTUQ}!O'[!Q!['[!c!}'[#R#S'[#T#o'[T'uQ[S!f!g'{!n!o(dP(OP!c!d(RP(UP!v!w(XP([P!c!d(_P(dOSPP(gP!q!r(jP(mP!i!j(pP(sP!k!l(vP(yP!e!f(|P)ROWPT)YOlP[S~)_P[S!]!^)b~)gSP~OY)bZ;'S)b;'S;=`)s<%lO)b~)vP;=`<%l)bV*QVUQ[S}!O'[!Q!['[!c!q'[!q!r*g!r!}'[#R#S'[#T#o'[R*lVUQ}!O'[!Q!['[!c!y'[!y!z+R!z!}'[#R#S'[#T#o'[R+WVUQ}!O'[!Q!['[!c!p'[!p!q+m!q!}'[#R#S'[#T#o'[R+tTUQ_P}!O'[!Q!['[!c!}'[#R#S'[#T#o'[V,[VUQ[S}!O'[!Q!['[!c!g'[!g!h,q!h!}'[#R#S'[#T#o'[R,vVUQ}!O'[!Q!['[!c!h'[!h!i-]!i!}'[#R#S'[#T#o'[R-bVUQ}!O'[!Q!['[!c!v'[!v!w+m!w!}'[#R#S'[#T#o'[V.OVUQ[S}!O'[!Q!['[!c!t'[!t!u.e!u!}'[#R#S'[#T#o'[R.jVUQ}!O'[!Q!['[!c!k'[!k!l/P!l!}'[#R#S'[#T#o'[R/UVUQ}!O'[!Q!['[!c!p'[!p!q/k!q!}'[#R#S'[#T#o'[R/pVUQ}!O'[!Q!['[!c!v'[!v!w0V!w!}'[#R#S'[#T#o'[R0^TYPUQ}!O'[!Q!['[!c!}'[#R#S'[#T#o'[V0tVUQ[S}!O'[!Q!['[!c!w'[!w!x1Z!x!}'[#R#S'[#T#o'[R1`VUQ}!O'[!Q!['[!c!g'[!g!h1u!h!}'[#R#S'[#T#o'[R1zVUQ}!O'[!Q!['[!c!w'[!w!x2a!x!}'[#R#S'[#T#o'[R2fVUQ}!O'[!Q!['[!c!g'[!g!h2{!h!}'[#R#S'[#T#o'[R3STUQTP}!O'[!Q!['[!c!}'[#R#S'[#T#o'[V3jXUQ[S}!O'[!Q!['[!c!g'[!g!h4V!h!k'[!k!l5p!l!}'[#R#S'[#T#o'[R4[UUQ}!O'[!Q!['[!c!d4n!d!}'[#R#S'[#T#o'[R4sVUQ}!O'[!Q!['[!c!f'[!f!g5Y!g!}'[#R#S'[#T#o'[R5aTUQ^P}!O'[!Q!['[!c!}'[#R#S'[#T#o'[R5uVUQ}!O'[!Q!['[!c!i'[!i!j6[!j!}'[#R#S'[#T#o'[R6aVUQ}!O'[!Q!['[!c!j'[!j!k-]!k!}'[#R#S'[#T#o'[V6}XUQ[S}!O'[!Q!['[!c!e'[!e!f7j!f!v'[!v!w:[!w!}'[#R#S'[#T#o'[R7oUUQ}!O'[!Q!['[!c!d8R!d!}'[#R#S'[#T#o'[R8WVUQ}!O'[!Q!['[!c!p'[!p!q8m!q!}'[#R#S'[#T#o'[R8tUYPUQpq9W}!O'[!Q!['[!c!}'[#R#S'[#T#o'[P9ZQ!n!o9a!t!u9xP9dP!g!h9gP9jP!h!i9mP9pP!v!w9sP9xOYPP9{P!k!l:OP:RP!i!j:UP:XP!j!k9mR:aUUQ}!O'[!Q!['[!c!d:s!d!}'[#R#S'[#T#o'[R:xVUQ}!O'[!Q!['[!c!e'[!e!f;_!f!}'[#R#S'[#T#o'[R;dVUQ}!O'[!Q!['[!c!m'[!m!n2{!n!}'[#R#S'[#T#o'[V<QUUQ[S}!O'[!Q!['[!c!d<d!d!}'[#R#S'[#T#o'[R<iVUQ}!O'[!Q!['[!c!r'[!r!s2a!s!}'[#R#S'[#T#o'[V=VVUQ[S}!O'[!Q!['[!c!r'[!r!s+m!s!}'[#R#S'[#T#o'[V=sVUQ[S}!O'[!Q!['[!c!t'[!t!u>Y!u!}'[#R#S'[#T#o'[R>_VUQ}!O'[!Q!['[!c!k'[!k!l>t!l!}'[#R#S'[#T#o'[R>yVUQ}!O'[!Q!['[!c!v'[!v!w?`!w!}'[#R#S'[#T#o'[R?eVUQ}!O'[!Q!['[!c!g'[!g!h5Y!h!}'[#R#S'[#T#o'[T@ROfP[SS@UP;=`<%l$n",
	tokenizers: [0, 1, 2],
	topRules: { "Program": [0, 2] },
	tokenPrec: 156
});

const AbsMacLanguage = LRLanguage.define({
	parser: parser.configure({
		props: [
			foldNodeProp.add({
				DataSection: foldInside,
				LogicSection: foldInside
			}),
			styleTags({
				Symbol: tags.number,
				Identifier: tags.variableName,
				LineComment: tags.lineComment,
				StorageType: tags.bool,
				FSACommand: tags.className,
				PDACommand: tags.className,
				TMCommand: tags.className,
				".DATA": tags.string,
				".LOGIC": tags.string,
			})
		]
	}),
	languageData: {
		commentTokens: { line: ";;" }
	}
});
const AbsMacCompletion = AbsMacLanguage.data.of({
	autocomplete: completeFromList([
		{ label: '.DATA', type: 'text' },
		{ label: '.LOGIC', type: 'text' },
		{ label: 'STACK', type: 'type' },
		{ label: 'QUEUE', type: 'type' },
		{ label: 'TAPE', type: 'type' },
		{ label: 'SCAN', type: 'keyword' },
		{ label: 'PRINT', type: 'keyword' },
		{ label: 'SCAN RIGHT', type: 'keyword' },
		{ label: 'SCAN LEFT', type: 'keyword' },
		{ label: 'READ', type: 'keyword' },
		{ label: 'WRITE', type: 'keyword' },
		{ label: 'RIGHT', type: 'keyword' },
		{ label: 'LEFT', type: 'keyword' },
		{ label: 'UP', type: 'keyword' },
		{ label: 'DOWN', type: 'keyword' },
		{ label: 'accept', type: 'keyword' },
		{ label: 'reject', type: 'keyword' },
	])
});
function AbsMac() {
	return new LanguageSupport(AbsMacLanguage, [AbsMacCompletion]);
}

export { AbsMac, AbsMacCompletion, AbsMacLanguage };
